<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Monitoring</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1000px;
            margin: auto;
            border: 2px solid #ddd;
            padding: 10px;
        }

        .upper-section {
            display: flex;
            justify-content: space-between;
			margin-bottom: 10px;
        }

        #boundsChart {
            flex: 1;
            max-width: 600px;
            height: 430px;
        }

        .info {
            flex: 1;
            margin-left: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
			height: 120px;
        }

        .log-box {
            border: 1px solid #ccc;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            background-color: #f9f9f9;
            word-wrap: break-word;
            font-size: 12px;
            margin-top: 20px;
            animation: logWarning 0s;
        }

        h2 {
            margin: 5px 0;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            background-color: #eee;
            border-radius: 3px;
            word-wrap: break-word;
        }

        <!-- @keyframes logWarning { -->
            <!-- from { -->
                <!-- background-color: #f9f9f9; -->
            <!-- } -->

            <!-- to { -->
                <!-- background-color: #ffcccc; -->
            <!-- } -->
        <!-- } -->
		
		<!-- ######### 추가된 부분 ######### -->
        @keyframes colorInvert {
            from {
                filter: invert(0%);
            }
            to {
                filter: invert(100%);
            }
        }

        .log-box.inverted {
            animation: colorInvert 0.5s ease;
            animation-fill-mode: forwards;
        }
        <!-- ######### 추가된 부분 ######### -->
    </style>
</head>

<body>
    <h1 style="text-align: center;">Real-time Monitoring</h1>
    <div class="container">
        <div class="upper-section">
            <canvas id="boundsChart"></canvas>
            <div class="info">
                <h2>로그 시계열 패턴 이상치 검출: <span id="MovingAverage_result">0</span></h2>
                <h2>로그 순서 패턴 이상치 검출: <span id="LSTM_result">0</span></h2>
            </div>
        </div>
        <div class="log-box">
            <h3>이상 로그:</h3>
            <div id="logEntries"></div>
        </div>
    </div>
    <script>
        const movingAverageElement = document.getElementById('MovingAverage_result');
        const LSTMElement = document.getElementById('LSTM_result');
        const logEntriesElement = document.getElementById('logEntries');
        const logBox = document.querySelector('.log-box');
        const ctx = document.getElementById('boundsChart').getContext('2d');
		
		
		<!-- 로그 넘버링을 위한 변수 추가  -->
		let logCounter = 1;
		<!-- 로그 넘버링을 위한 변수 추가  -->


        const boundsChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    // {
                    //     label: 'Min Bound',
                    //     data: [],
                    //     borderColor: 'blue',
                    //     pointRadius: 0,
                    //     fill: false
                    // },
                    {
                        label: 'Max Bound',
                        data: [],
                        borderColor: 'red',
                        pointRadius: 0,
                        fill: false
						//tension: 0.3
						//cubicInterpolationMode: 'monotone'
                    }, {
                        label: 'Actual Time (Seconds)',
                        data: [],
                        borderColor: 'purple',
                        pointRadius: 0,
                        fill: false
						//tension: 0.4
						//cubicInterpolationMode: 'monotone'
                    }
                ]
            },
            options: {
				maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom'
                    }
                },
                <!-- animation: { -->
                    <!-- duration: 0 // 애니메이션 제거 -->
                <!-- }, -->
                <!-- elements: { -->
                    <!-- line: { -->
                        <!-- tension: 0 // 직선 연결 -->
                    <!-- } -->
                <!-- }, -->
                plugins: {
                    legend: {
                        display: true
                    },
                    tooltip: {
                        enabled: true
                    }
                }
            }
        });

        function fetchData() {
            fetch('/data')
                .then(response => response.json())
                .then(data => {
                    movingAverageElement.textContent = data.result;
                    LSTMElement.textContent = data.LSTM_result;

                    const currentTime = boundsChart.data.labels.length > 0
                        ? boundsChart.data.labels[boundsChart.data.labels.length - 1] + 1
                        : 0;

                    boundsChart.data.labels.push(currentTime);
                    // boundsChart.data.datasets[0].data.push(data.bounds[0]);  // Min Bound
                    boundsChart.data.datasets[0].data.push(data.bounds[1]);  // Max Bound
                    boundsChart.data.datasets[1].data.push(data.user_time_seconds);  // User Time (Seconds)
					
					// X축 범위가 고정된 가운데 새로운 데이터를 추가 시작 ################
					const maxDataPoints = 200; // 표시할 데이터 포인트 수
					const centerPoint = Math.floor(maxDataPoints / 2); // 가운데 지점

					if (boundsChart.data.labels.length > maxDataPoints) {
						const start = currentTime - centerPoint;
						const end = currentTime + centerPoint;

						// X축을 가운데에 새로운 데이터가 추가되도록 설정
						boundsChart.options.scales.x.min = start;
						boundsChart.options.scales.x.max = end;
					} else {
						// 데이터가 100개 이하일 때 X축 범위 설정
						boundsChart.options.scales.x.min = 0;
						boundsChart.options.scales.x.max = maxDataPoints;
					}
					// X축 범위가 고정된 가운데 새로운 데이터를 추가 끝 ################


                    boundsChart.update();

                    // Check if both results are 1 and log the entry
                    if (data.result === 1 && data.LSTM_result === 1) {
                        const logEntry = document.createElement('div');
                        logEntry.className = 'log-entry';
                        logEntry.textContent = `${logCounter}. 이상 로그: ${data.log}`;
                        logEntriesElement.appendChild(logEntry);
						// 로그 넘버링 
						logCounter++;
                        
						// 로그 추가 후 자동 스크롤
                        logBox.scrollTop = logBox.scrollHeight;
						
                        // 색반전 애니메이션 적용
                        logBox.classList.add('inverted');

                        // 애니메이션이 끝나면 클래스 제거
                        setTimeout(() => {
                            logBox.classList.remove('inverted');
                        }, 500);
                        
                    }
                });
        }
		
		// Y축 조정 함수 시작 ################
        function adjustYAxis() {
            // Calculate the min and max values for y-axis dynamically
            const allData = boundsChart.data.datasets.reduce((acc, dataset) => {
                return acc.concat(dataset.data);
            }, []);

			

            const minValue = Math.min(...allData);
            const maxValue = Math.max(...allData);
			
			allData.sort((a, b) => a - b);
			
			const secondSmallest = allData[1];

            boundsChart.options.scales.y.min = secondSmallest * 0.9; // 여유 있게 10% 줄이기
            boundsChart.options.scales.y.max = maxValue * 2; // 여유 있게 10% 늘리기

            boundsChart.update();
			
			// Y축 자동 조정 모드로 복원 시작 ################
			// 이후 추가되는 데이터에 따라 Y축이 자동으로 조정되도록 설정
			setTimeout(() => {
				boundsChart.options.scales.y.min = null;
				boundsChart.options.scales.y.max = null;
				boundsChart.update();
			}, 5000); // 5초 후 자동 조정 모드로 복원 (적절한 시간으로 설정 가능)
			// Y축 자동 조정 모드로 복원 끝 ################
        }
        // Y축 조정 함수 끝 ################


        setInterval(fetchData, 100); // 0.1초마다 데이터 가져오기
		
		// 1분마다 Y축 조정하기 시작 ################
        //setInterval(adjustYAxis, 60000); // 60000ms = 1분
        // 1분마다 Y축 조정하기 끝 ################
    </script>
</body>

</html>
